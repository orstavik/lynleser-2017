<link rel="import" href="controller-transient.html">
<link rel="import" href="data-firebase.html">
<link rel="import" href="../bower_components/app-storage/app-indexeddb-mirror/app-indexeddb-mirror.html">

<dom-module id="controller-persistent">
  <template>
    <style>
      :host {
        display: block;
      }
    </style>

    <data-firebase id="firebase"
                   server-user="{{serverUser}}"
                   generic-state="{{serverGenericState}}"
                   user-state="{{serverUserState}}"

                   on-book-loaded="_bookLoaded"
                   on-system-error="_systemError"></data-firebase>

    <app-indexeddb-mirror
        key="bookList"
        data="{{serverGenericState}}"
        persisted-data="{{persistedGenericState}}">
    </app-indexeddb-mirror>

    <controller-transient id="ui"
                          user="[[serverUser]]"
                          user-data="[[state]]"
                          on-select-book="_selectBook"
                          on-settings-changed="_userSetNewSettings"
                          on-sign-in="_signIn"
                          on-sign-out="_signOut"></controller-transient>
  </template>

  <script>

    class ControllerPersistent extends Polymer.Element {
      static get is() {
        return "controller-persistent";
      }

      //important.
      //1. The structure of States must be overlapping, as similar as possible.
      //   This makes merging simpler and update calls to the DB simpler.
      //3. The order of merging: least updated data source of a branch that are merging are put first.
      //   Branches are merged as late as possible. This produces the fewest new Objects and thus updates.
      //4. Immutable. States are immutable by default, only but we can use Mutable States and wildcard observers.

      static get properties() {
        return {
          timeMachine: Array,
          serverUser: Object,

          defaultState: State,                //a. DEFAULT
          serverGenericState: Object,         //b. DB firebase
          persistedGenericState: Object,      //b2. localStorage
          serverUserState: Object,            //c. DB firebase
          serverBooks: Object,                //e. BUCKETS firebase
          fluidState: MutableState,           //d. FLUID changes from the UI

          genericUserState: {
            type: State,
            computed: "_mergeStates(defaultState, persistedGenericState)"
          },
          specificUserState: {
            type: State,
            computed: "_mergeStates(genericUserState, serverUserState)"
          },
          mergedFluidState: {
            type: State,
            computed: "_mergeFluidState(specificUserState, fluidState.*)"
          },
          state: {
            type: State,
            computed: "_mergeBookData(mergedFluidState, serverBooks)"
          },
        };
      }

      static get observers(){
        return ["_persistChanges(fluidState.*)"];
      }

      constructor(){
        super();
        this.setProperties({
          fluidState: new MutableState(),
          serverBooks: {},
          defaultState: new DefaultState(),
          timeMachine: []
        });
      }

      _mergeStates(A, B) {
        return State.merge(A, B);
      }

      _mergeFluidState(A, B) {
        return State.merge(A, B.base);
      }

      _mergeBookData(state, bookData) {
        if (!bookData || !state || !state.settings.activeBook || !state.settings.activeBook.key) //not enough data
          return state;
        if (state.settings.activeBook.body)                                                      //already have active book
          return state;
        const active = state.settings.activeBook.key;
        if (!bookData[active])                                                                   //no activeBook in bookData
          return state;
        const stateWithBookData = {settings: {activeBook: bookData[active]}};
        const finalState = State.merge(state, stateWithBookData);
        this.timeMachine.push(finalState);
        return finalState;
      }

      _signIn(e) {
        this.fluidState = new MutableState();
        this.$.firebase.signIn();
      }

      _signOut(e) {
        this.$.firebase.signOut();
      }

      _selectBook(e) {
        this.set("fluidState.settings.activeBook", e.detail);
        this.$.firebase.getBook(e.detail);
      }

      _systemError(e) {
        console.log("Error");
        console.log(e);
      }

      _bookLoaded(e) {
        const clone = Object.assign({}, this.serverBooks);
        clone[e.detail.key] = e.detail;
        this.set("serverBooks", clone);
      }

      _userSetNewSettings(e) {
        this.set("fluidState.settings." + e.detail.key, e.detail.value);
      }

      _persistChanges(uiData) {
        uiData = uiData.base;
        if (!this.serverUser || !uiData || uiData.isEmpty())
          return;
        this.debounce(function () {
          uiData.reduceOverlapping(this.specificUserState);
          this.$.firebase.updateChanges(uiData);
        }.bind(this), 5000);
      }

      debounce(fn, time) {
        if (this.__bounce)
          clearTimeout(this.__bounce);
        this.__bounce = setTimeout(fn, time);
      }
    }
    customElements.define(ControllerPersistent.is, ControllerPersistent);
  </script>
</dom-module>